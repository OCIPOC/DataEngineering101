# Ref

book

[github](https://github.com/Vonng/ddia/blob/master/ch1.md)

# Intro

現今很多應用程式是資料密集性(data-intensive)，而非計算密集型(compute-intensive)，因為CPU很少成為這一類型的瓶頸，更大的問題通常來自於**資料量**、**資料複雜性**、**資料變化的速度**

資料密集型應用程式通常是由一些常見功能的標準模組構建而成，例如以下組件

1. 資料庫 (databases) : 儲存資料
2. 快取 (caches) : 將昂貴的計算結果儲存起來，使讀取操作更快
3. 搜尋索引(search index) : 試用者可以透過關鍵字來搜尋資料或是隻個種過率茲料的方式
4. 串流處理(stream processing) : 將訊息發送至另一個程序，且推甭物的方式進行處理
5. 批次處理(batch processing) : 週期性地處理大量資料

以上需求看起來很平常，是因為這些資料處理系統，有著很成功的抽象層(工程師不用重新寫一個資料庫)

但現實不總時那麼簡單，例如各種不同的資料庫就有不同的特性，本書會先探討實踐的基礎，**可靠、可拓展、可維護**的資料系統

# 資料系統思維

現今的應用往往有廣泛的要求，你往往需要搭配以上各種不同的組件來完善你的資料系統，例如以下架構

<img src='assets/ddia1_1.png'></img>

1. 由於希望可以降低 response time，將資料存取於快取層(利如Redis)，當client進入時，會先在這一層檢查有沒有資料
2. 如果在第一層沒有找到資料，那麼可能會進入主資料庫找資料
3. 或者 client 是透過一個搜尋 bar 在搜尋想要的物品，那麼使用者每打一個字，就會送出一個 requests 致 search index 進行搜尋
4. client 完成某些操作之後，可以繼續client自己的操作，然而後台必須送出一封信件至使用者的email

那麼以上系統的不同組建之間會存在**如何同步**，**規模化**的問題

# 可靠性

對於軟體，典型的期望有

1. 應用程式可以執行使用者所期望的功能
2. 能夠容忍使用者的錯誤或已不正確的方式操作軟體
3. 在預期的負載和資料性下，性能可以滿足需求
4. 系統能夠防止未經授權的訪問

容錯不等於可以容忍所有錯誤，而是對於常見的錯誤具有可以容忍性，具體的定義要看你的系統而定	

## 硬碟故障

硬碟壞軌、記憶體掛點、停電、拔錯網路線，任何一個與大型資料中心合作過的人都可以告訴你這很常見

pass

## 軟體錯誤

1. 2012年6月30，閏秒，Linux和心中的一個bug，導致可以透過特定輸入讓很多應用程式當機
2. 失控的process，造成共享資源(CPU, 記憶體, 硬碟, 網路頻寬)的異常消耗
3. 系統所依賴的服務變慢，沒有回應，或者開始傳回異常
4. 連鎖故障(先壞A，再壞B，再壞C)

導致這一類的軟體故障bug通常會前副很長一段時間，直到被特定事件觸發

## 人為失誤

人除了設計和構建系統之外，也負責維護系統，一項對於大型網路服務的研究發現，組態配置錯誤是導致系統崩潰的主要原因，軟體故障和硬體故障只佔了總體10~15%

那麼如何保證系統的可靠性?

1. 設計時就減少出錯機會 - 精心設計的抽象層、API、管理介面，可以很容易**做對的事情**，**不容易做錯的事情**，但如果介面限制太多，人們就會想要繞過它，這一點需要取得平衡
2. 將人們容易出錯的地方、引發故障的地方分開，提供一個功能齊全的sandbox(例如開發環境)，讓開發者可以在其中探索和嘗試，且避免影響到使用者
3. 在所有級別進行測試(單元測試、系統整合測試、手動測試)
4. 可輕鬆快速的從人為錯誤中修復(快速回滾的組態變更、滾動發布程式碼、提供資料校驗工具)
5. 建立詳細的間空系統(包含性能指標和錯誤率)
6. 實踐良好的管理實踐和培訓
   
## 可靠性有多重要

商業應用系統的bug會讓生產力下降，甚至因資料報告錯誤帶來法律風險

網站當機會造成營收和聲譽損失

# 可擴展性
## 描述負載
## 描述性能
## 應對負載壓力的方法

# 可維護性
## 朝無痛維護邁進
## 簡單性 : 掌握複雜度
## 可演化性

# 小結
